import yfinance as yf
import pandas as pd
import pandas_ta as ta
import numpy as np
from datetime import datetime, timedelta
from newsapi import NewsApiClient
import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import os

class StockTradingBot:
    def __init__(self, news_api_key, risk_per_trade=0.01, stop_loss_pct=0.07, take_profit_pct=0.1):
        """
        Initialize the trading bot.
        """
        self.news_api = NewsApiClient(api_key=news_api_key)
        self.risk_per_trade = risk_per_trade
        self.stop_loss_pct = stop_loss_pct
        self.take_profit_pct = take_profit_pct
        self.portfolio_value = 9000  # Your portfolio size ($9,000)
        self.stock_list = self.update_stock_list()  # Initialize stock list

    def update_stock_list(self):
        """
        Fetch a dynamic list of stocks based on market cap and volume.
        Always include TNXP.
        """
        try:
            # Fetch S&P 500 tickers (approximated via yfinance)
            sp500 = yf.Tickers('^GSPC').tickers['^GSPC'].info
            # Use a proxy list of top US stocks (yfinance doesn't directly provide S&P 500 list)
            # Alternative: Use a predefined list of top stocks or scrape a source
            # For simplicity, we'll use a curated list of large-cap stocks and filter
            candidate_tickers = [
                'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'TSLA', 'NVDA', 'JPM', 'V', 'WMT',
                'PG', 'KO', 'PFE', 'AMD', 'INTC', 'F', 'T', 'VZ', 'PLTR', 'CSCO', 'BAC', 'XOM'
            ]
            # Always include TNXP
            if 'TNXP' not in candidate_tickers:
                candidate_tickers.append('TNXP')

            stock_list = []
            for ticker in candidate_tickers:
                try:
                    stock = yf.Ticker(ticker)
                    info = stock.info
                    price = info.get('currentPrice', 0)
                    volume = info.get('averageVolume', 0)
                    # Filter: price $10–$100, volume > 1M
                    if 10 <= price <= 100 and volume >= 1_000_000:
                        stock_list.append(ticker)
                    elif ticker == 'TNXP':  # Always include TNXP
                        stock_list.append(ticker)
                except Exception as e:
                    print(f"Error processing {ticker} for stock list: {e}")

            # Limit to 25 stocks to stay within NewsAPI limits
            return stock_list[:25]
        except Exception as e:
            print(f"Error updating stock list: {e}")
            # Fallback to default list with TNXP
            return ['TNXP', 'AMD', 'F', 'PFE', 'KO', 'T', 'INTC', 'VZ', 'PLTR', 'CSCO']

    def fetch_stock_data(self, ticker, days=100):
        """
        Fetch historical stock data.
        """
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        stock = yf.Ticker(ticker)
        df = stock.history(start=start_date, end=end_date, interval="1d")
        return df

    def calculate_indicators(self, df):
        """
        Calculate technical indicators (RSI, SMA, EMA).
        """
        df['RSI'] = ta.rsi(df['Close'], length=14)
        df['SMA_20'] = ta.sma(df['Close'], length=20)
        df['EMA_50'] = ta.ema(df['Close'], length=50)
        return df

    def fetch_news(self, ticker):
        """
        Fetch recent news and determine sentiment.
        """
        try:
            news = self.news_api.get_everything(q=ticker, language='en', sort_by='relevancy', page_size=5)
            articles = news.get('articles', [])
            if not articles:
                return 0, "No recent news found"

            positive_keywords = ['surge', 'beats', 'positive', 'approval', 'strong', 'gain', 'success', 'breakthrough']
            negative_keywords = ['drop', 'loss', 'decline', 'miss', 'negative', 'plunge', 'fail']
            sentiment_score = 0
            top_headline = articles[0]['title'] if articles else "No headline"

            for article in articles:
                text = (article['title'] or '') + ' ' + (article['description'] or '')
                text = text.lower()
                for word in positive_keywords:
                    if word in text:
                        sentiment_score += 1
                for word in negative_keywords:
                    if word in text:
                        sentiment_score -= 1

            sentiment_score = 1 if sentiment_score > 0 else (-1 if sentiment_score < 0 else 0)
            return sentiment_score, top_headline
        except Exception as e:
            print(f"Error fetching news for {ticker}: {e}")
            return 0, "News fetch failed"

    def generate_signals(self, df):
        """
        Generate buy signals based on technical indicators.
        """
        latest = df.iloc[-1]
        second_latest = df.iloc[-2]
        buy_signal = (latest['RSI'] < 30) and (latest['Close'] > latest['SMA_20']) and (second_latest['Close'] <= second_latest['SMA_20'])
        return buy_signal, latest['Close'], latest['RSI']

    def calculate_position_size(self, entry_price, stop_loss_price):
        """
        Calculate position size based on risk management.
        """
        risk_amount = self.portfolio_value * self.risk_per_trade
        risk_per_share = entry_price - stop_loss_price
        if risk_per_share <= 0:
            return 0
        shares = int(risk_amount / risk_per_share)
        return min(shares, int(self.portfolio_value / entry_price))

    def analyze_stocks(self):
        """
        Analyze stocks and return top 5 picks.
        """
        recommendations = []
        for ticker in self.stock_list:
            try:
                df = self.fetch_stock_data(ticker)
                if df.empty:
                    continue
                
                df = self.calculate_indicators(df)
                buy_signal, current_price, rsi = self.generate_signals(df)
                
                sentiment_score, headline = self.fetch_news(ticker)
                
                if buy_signal and current_price >= 1 and sentiment_score >= 0:
                    stop_loss_price = current_price * (1 - self.stop_loss_pct)
                    take_profit_price = current_price * (1 + self.take_profit_pct)
                    shares = self.calculate_position_size(current_price, stop_loss_price)
                    
                    if shares > 0:
                        recommendations.append({
                            'Ticker': ticker,
                            'Price': round(current_price, 2),
                            'RSI': round(rsi, 2),
                            'Stop_Loss': round(stop_loss_price, 2),
                            'Take_Profit': round(take_profit_price, 2),
                            'Shares': shares,
                            'Risk_Reward_Ratio': round(self.take_profit_pct / self.stop_loss_pct, 2),
                            'Sentiment': 'Positive' if sentiment_score > 0 else 'Neutral',
                            'Headline': headline,
                            'Data': df
                        })
            except Exception as e:
                print(f"Error processing {ticker}: {e}")
        
        recommendations = sorted(recommendations, key=lambda x: (-(x['Sentiment'] == 'Positive'), x['RSI']))[:5]
        return recommendations

class StockBotGUI:
    def __init__(self, root, news_api_key):
        """
        Initialize the GUI.
        """
        self.root = root
        self.root.title("Stock Trading Bot")
        self.root.geometry("1000x600")
        self.bot = StockTradingBot(news_api_key=news_api_key)
        
        # Portfolio Summary
        self.summary_label = tk.Label(root, text=f"Portfolio: ${self.bot.portfolio_value} | Risk per Trade: {self.bot.risk_per_trade*100}% | Stop-Loss: {self.bot.stop_loss_pct*100}% | Take-Profit: {self.bot.take_profit_pct*100}%", font=("Arial", 12))
        self.summary_label.pack(pady=10)
        
        self.note_label = tk.Label(root, text="Note: Select 1–3 of the 5 picks to avoid overexposure.", font=("Arial", 10, "italic"))
        self.note_label.pack()
        
        # Stock List Display
        self.stock_list_var = tk.StringVar(value=f"Analyzing Stocks: {', '.join(self.bot.stock_list)}")
        self.stock_list_label = tk.Label(root, textvariable=self.stock_list_var, font=("Arial", 10), wraplength=950)
        self.stock_list_label.pack(pady=5)
        
        # Status Bar
        self.status_var = tk.StringVar(value="Ready")
        self.status_label = tk.Label(root, textvariable=self.status_var, font=("Arial", 10), fg="blue")
        self.status_label.pack(pady=5)
        
        # Refresh Button
        self.refresh_button = tk.Button(root, text="Refresh Recommendations", command=self.refresh_recommendations, bg="lightblue", font=("Arial", 12))
        self.refresh_button.pack(pady=5)
        
        # Table for Recommendations
        self.tree = ttk.Treeview(root, columns=("Ticker", "Price", "RSI", "Stop_Loss", "Take_Profit", "Shares", "Risk_Reward", "Sentiment", "Headline", "Chart"), show="headings")
        self.tree.heading("Ticker", text="Ticker")
        self.tree.heading("Price", text="Price ($)")
        self.tree.heading("RSI", text="RSI")
        self.tree.heading("Stop_Loss", text="Stop-Loss ($)")
        self.tree.heading("Take_Profit", text="Take-Profit ($)")
        self.tree.heading("Shares", text="Shares")
        self.tree.heading("Risk_Reward", text="Risk-Reward")
        self.tree.heading("Sentiment", text="Sentiment")
        self.tree.heading("Headline", text="Top Headline")
        self.tree.heading("Chart", text="Chart")
        self.tree.column("Ticker", width=60)
        self.tree.column("Price", width=80)
        self.tree.column("RSI", width=60)
        self.tree.column("Stop_Loss", width=100)
        self.tree.column("Take_Profit", width=100)
        self.tree.column("Shares", width=60)
        self.tree.column("Risk_Reward", width=80)
        self.tree.column("Sentiment", width=80)
        self.tree.column("Headline", width=300)
        self.tree.column("Chart", width=60)
        self.tree.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(root, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        
        # Save Button
        self.save_button = tk.Button(root, text="Save Recommendations to CSV", command=self.save_recommendations, bg="lightgreen", font=("Arial", 12))
        self.save_button.pack(pady=5)
        
        # Initial Load
        self.refresh_recommendations()

    def plot_chart(self, df, ticker):
        """
        Plot a price chart for a stock.
        """
        fig, ax = plt.subplots(figsize=(6, 4))
        ax.plot(df.index, df['Close'], label=f"{ticker} Price", color="blue")
        ax.plot(df.index, df['SMA_20'], label="20-day SMA", color="orange")
        ax.set_title(f"{ticker} Price Trend")
        ax.set_xlabel("Date")
        ax.set_ylabel("Price ($)")
        ax.legend()
        ax.grid(True)
        
        chart_window = tk.Toplevel(self.root)
        chart_window.title(f"{ticker} Chart")
        canvas = FigureCanvasTkAgg(fig, master=chart_window)
        canvas.draw()
        canvas.get_tk_widget().pack()
        plt.close(fig)

    def refresh_recommendations(self):
        """
        Fetch new stock list and recommendations.
        """
        self.status_var.set("Updating stock list and fetching data...")
        self.root.update()
        
        # Update stock list
        self.bot.stock_list = self.bot.update_stock_list()
        self.stock_list_var.set(f"Analyzing Stocks: {', '.join(self.bot.stock_list)}")
        
        # Clear table
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        recommendations = self.bot.analyze_stocks()
        if not recommendations:
            messagebox.showinfo("No Recommendations", "No stocks meet the buy criteria today.")
            self.status_var.set("No recommendations found")
            return
        
        for rec in recommendations:
            self.tree.insert("", "end", values=(
                rec['Ticker'],
                rec['Price'],
                rec['RSI'],
                rec['Stop_Loss'],
                rec['Take_Profit'],
                rec['Shares'],
                f"{rec['Risk_Reward_Ratio']}:1",
                rec['Sentiment'],
                rec['Headline'],
                "View"
            ), tags=(rec['Ticker'],))
        
        self.tree.tag_bind("View", "<Button-1>", lambda event: self.on_chart_click(event, recommendations))
        self.status_var.set(f"Done - {len(recommendations)} recommendations found")
    
    def on_chart_click(self, event, recommendations):
        """
        Handle chart button click.
        """
        item = self.tree.identify_row(event.y)
        if not item:
            return
        column = self.tree.identify_column(event.x)
        if column == "#10":
            ticker = self.tree.item(item, "values")[0]
            for rec in recommendations:
                if rec['Ticker'] == ticker:
                    self.plot_chart(rec['Data'], ticker)
                    break

    def save_recommendations(self):
        """
        Save recommendations to CSV.
        """
        recommendations = self.bot.analyze_stocks()
        if not recommendations:
            messagebox.showinfo("No Data", "No recommendations to save.")
            return
        
        df = pd.DataFrame(recommendations)
        df = df.drop(columns=['Data'])
        filename = f"recommendations_{datetime.now().strftime('%Y-%m-%d')}.csv"
        df.to_csv(filename, index=False)
        messagebox.showinfo("Saved", f"Recommendations saved to {filename}")

if __name__ == "__main__":
    NEWS_API_KEY = 'c715f7725a3147dfbfa89e8d51ecd49b'  # Replace with your NewsAPI key
    root = tk.Tk()
    app = StockBotGUI(root, NEWS_API_KEY)
    root.mainloop()
